DEEP SPOT
=========

Immediate todos
---------------
* CPU MADE ILLEGAL MOVE. Had only one move available at end of game and passed. "Searched 77 nodes in 0 seconds"
** Must not have found a better move than alpha, which was -INFINITY, and so returned no move.

* DID WE BREAK ALPHA-BETA AND/OR ZOBRIST??
** At 8 ply, best-first on, null move off, iterative negamax used to search 6,429,292 nodes after a1-b1. Now it searches 9,606,792 (returning the same score). However, MTD(f) searched 6,535,305 with the old method (returning a score of -4) and 1,600,989 with the new (returning a score of -1). What's going on??
*** We may have to do a 2-ply search and just brute-force it by hand to see what it SHOULD be doing versus what it IS doing.

* MTD(f) does not match between BB and non-BB w/ zobrist on -- but iterative negamax does match, and MTD(f) matches with zobrist off.
** It's because BB version looks root node up in transposition table and vanilla does not. I'm unclear on why this is causing BB to search *more* nodes.

* What happens in MTD(f) when the CPU is about to lose the game? Is it gonna slide the null window towards -INFINITY one at a time, since it will fail low over and over?
** May not be a problem in practice. If you're about to lose, it doesn't really matter what move you play, and you'll find at least one move if you're doing iterative deepening, so the time limit might take care of it.

* NULL MOVE HEURISTIC
** Make sure null move is never recorded as best move in zobrist!
** It's not very effective, is it? But try it in more complex positions to be sure.
** Do we turn off writing to transposition table inside null branches or not?
** Maybe allow recursive null moves (but don't search null move if parent was a null move)

* Make non-BB and BB versions use exactly the same search algorithm. Then you can see what value the bitboards alone bring, and you can compare the accuracy much more, well, accurately. Current known differences:
** Performance difference: vanilla creates a vector on every move; BB does not.


Terminology
-----------
Capture square: A square the opponent can land on to capture a piece.


AI
--
Consider using 256-entry zobrist LUTs instead of 64k-entry LUTs for mobile devices (may work better with cache)

Try Enhanced Transposition Cutoffs (ETC) -- basically, check if any children nodes are in the transposition table and cut off if there is a beta cutoff. This is expensive, so is only worth doing higher up in the tree.

Hypothesis: even-numbered plies work best, because it doesn't matter if you grab a lot of pieces only to lose a large number of them one ply later.

Iterative deepening should cut off search once a score of +inf has been found. No need to search to 4 ply if the game will end in 3 moves.
* Do we do the same for a score of -inf?

What happens if a score of -inf is detected? Will the computer start making random moves, since no move seems better than any other? And (once we allow them) what about draws?
* A solution here is to give the highest score to the move that defers loss the longest. Alternatively, it could return the result of the shallowest search that doesn't return a score of -inf (iterative shallowing?).

The order in which the CPU looks for jumps is still not randomized.

I think this game will show significant even/odd swings, so NegaScout may be better than MTD(f)

MTD(f) is making different moves than negamax, even with zobrist hashing off. Is this normal?

Zobrist hashing can be improved by using a "hash lock" -- instead of recording the full_hash, compute and record a DIFFERENT hash. Implement by modifying calcHash to accept different tables. There is the unfortunate side effect, though, that this doubles the time spent hashing.

Always examine one ply deeper when there is only one legal move (repeat as necessary).

Should give higher scores to winning the game in fewer moves, so the computer always plays the quickest win, not the first it finds. (If the win is only a few ply away, though, iterative deepening will catch it at the shallowest possible depth.)

Consider killer move heuristic

There might be situations analogous to superko in Go that would cause a game between two AIs to continue endlessly.

I'm thinking a piece is worth 100 points, a capture square is worth -N points (to encourage the algorithm to err on the side of reducing its capture squares), where N is the number of pieces that will be captured if the opponent moves there. (Calculate by iterating through the board, and if piece is of our color, adding up all the empty squares that neighbor it)


Time control
------------
Suppose you have 5 seconds for the next move. If after any ply more than 2.5 seconds have elapsed, you can probably terminate, since it's doubtful you will complete another ply with half your time remaining.


Testing AI
----------
Confirm findMoves and findAllPossibleMoves yield the same scores for every position

Generate (say) 1 million random positions. Verify that Negamax w/o alpha-beta, Negamax w/alpha-beta, and Negascout always return the same result for an N-ply search.

Also try random positions with different version of the algorithm to see how they perform.


Evaluating a position with bitboards
------------------------------------
Counting number of 1's one bit at a time:

    int count = 0;
    for(uint64 bits = bitboard; bits != 0; bits >>= 1) {
        count += bits & 1;
    }


Counting number of 1's with a lookup table (COUNT_BITS is 16-bit):

    int count = COUNT_BITS[bitboard & 0xffff];
    count += COUNT_BITS[(bitboard >> 16) & 0xffff];
    count += COUNT_BITS[(bitboard >> 32) & 0xffff];
    count += COUNT_BITS[(bitboard >> 48) & 0xffff];

Or equivalently:

    int count = 0;
    for(uint64 bits = bitboard; bits != 0; bits >>= 16) {
        count += COUNT_BITS[bits & 0xffff];
    }

A very similar trick can also be used with bitboards to make zobrist hashes!

    uint64 hash = ZOBRIST_BLUE1[bb_blue & 0xffff];
    hash ^= ZOBRIST_BLUE2[(bb_blue >> 16) & 0xffff];
    hash ^= ZOBRIST_BLUE3[(bb_blue >> 32) & 0xffff];
    hash ^= ZOBRIST_BLUE4[(bb_blue >> 48) & 0xffff];

Then repeat for red, and then hash in whose turn it is to move.


Draw bitboard routine
---------------------
def drawbb(bitboard):
    out = ""
    bit = 1
    for i in xrange(49):
        out += "1" if bitboard & bit else "0"
        if i % 7 == 6:
            out += "\n"
        bit <<= 1
    print out
